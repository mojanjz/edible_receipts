1. What are the ELF magic numbers?

2. What is the difference between UIO_USERISPACE and UIO_USERSPACE? When should one use UIO_SYSSPACE instead?

3. Why can the struct uio that is used to read in a segment be allocated on the stack in load_segment() (i.e., where does the memory read actually go)?

4. In runprogram(), why is it important to call vfs_close() before going to usermode?

5. What function forces the processor to switch into usermode? Is this function machine dependent?

6. In what file are copyin and copyout defined? memmove? Why can't copyin and copyout be implemented as simply as memmove?

7. What (briefly) is the purpose of userptr_t?

8. What is the numerical value of the exception code for a MIPS system call?



9. How many bytes is an instruction in MIPS? (Answer this by reading syscall() carefully, not by looking somewhere else.)
What is an instruction in MIPS, and how is it executed/linked to syscall?
Is it the same as the calling convention for syscall? If so then 4args*32bits/8(bits/byte) -> I dont think so
32 bits, 4 bytes
MIPS register is 32 bits, maybe look to syscalls-mips.S -> syscall function? Referenced in comments of syscall()

10. Why do you "probably want to change" the implementation of kill_curthread()?
We want to build a function that can kill the current thread when user-level code hits a fatal fault, instead of just panicking and crashing the kernel.  The current implementation,
just sends the thread into panic with the message "I don't know how to handle this\n". 

11. What would be required to implement a system call that took more than 4 arguments?
If you wanted to implement a system call that took more than 4 arguments, you would have to store your remaining arguments in the user-level stack.
Then, they would have to be fetched ysing copyin(), starting at sp+16 to skip the stored registerized values.

12. What is the purpose of the SYSCALL macro?
The SYSCALL macro is used to load the syscall number into the register v0 (which is the location in which the kernel expects to find it).
Next, it jumps to the shared syscall code (MIPS syscall ABI).

13. What is the MIPS instruction that actually triggers a system call? (Answer this by reading the source in this directory, not looking somewhere else.)

14. After reading syscalls-mips.S and syscall.c, you should be prepared to answer the following question: OS/161 supports 64-bit values; lseek() takes and returns a 64-bit offset value. Thus, lseek() takes a 32-bit file handle (arg0), a 64-bit offset (arg1), a 32-bit whence (arg2), and needs to return a 64-bit offset value. In void syscall(struct trapframe *tf) where will you find each of the three arguments (in which registers) and how will you return the 64-bit offset?

15. As you were reading the code in runprogram.c and loadelf.c, you probably noticed how the kernel manipulates the files. Which kernel function is called to open a file? Which macro is called to read the file? What about to write a file? Which data structure is used in the kernel to represent an open file? 

16. What is the purpose of VOP_INCREF and VOP_DECREF?