1) The thread is first detached from our process, then we check the stack guard band and then call thread_switch() which changes the state to ZOMBIE and adds it to the threadlist before the node and increments the threadlist counter to be destroyed by threadlist_destroy(). It also goes into panic mode in case it tries to run again before it dies. The main clean up is done by exorcise() which cleans up zombies. Exorcise() calls thread_destroy
which cleans up the threadlist, the thread stack as well as any other variable associated with the thread.
wchan_sleep() puts a whole channel to sleep. It first makes sure that the call is not an interrupt since this can't happen in an interrupt handler. It then ensures that it holds the lk spinlock which then thread_switch can release. It then calls thread_swtich with S_SLEEP state. In this case, thread_switch switches the state to S_SLEEP snd adds it to the wait channel. Calling wchan_wake then wakes up all threads in the wait channel. It then switches to the next thread in the thread_switch() function.
2) thread_switch is in charge of context switch. It calls switchframe_switch which switches the switchframe to the new thread from the old thread. 
3) There are four states for a thread that can be found in thread.h. S_RUN is when the thread is running, S_READY is when the thread has all stacks and variables ready and is ready to be run. S_SLEEP is when the thread is sleeping, and S_ZOMBIE is when the thread is exited but not yet deleted.
4) Turning off interrupts means that interrups cannot interrupt that part of the code and it can run atomically with no interruption at least from the same processor. This is accomplished by a method called splhigh() which changes the interrups to high priority, IPL_HIGH. Interrupts are not allowed to go through while spl is set to IPL_HIGH. It is vital to turn off interrupts for the code that is supposed to be running atomically with no interruption. This is very important in OS programming since threads and concurrent programming are the crucial part of the OS. We don't want to end up in an undeterminate state which can happen if certain parts of the code are not run atomically for example during a context switch.

5)wchan_wakeall wakes up all threads and wchan_wakeone is used when one thread is waking up another thread. This function first makes sure the spinlock is held. Then it gets the target thread to be woken up. It then makes the thread runnable. thread_make_runnable() changes the t_state to S_READY which then can be picked up by the scheduler the next time it runs. It also adds it to the runqueue so it's detectable by the scheduler, thread_swtich(). 

6) In thread_switch the next thread is found by the function threadlist_remhead() in threadlist.c.

7)threadlist_remhead() just looks at the threadlist and pops the first node, decrement the list counter and returns the next thread to thread_switch().

8) thread_yield() which calls thread_switch which in charge of scheduling is called from hardclock() in clock.c. This function is called based on the hardware timer from ltimer_irq which is an interrupt handler. The hardware independent function is thread_yield(). 

9) Semaphores are implemented in synch.c. wchan_sleep() is only called in the P function. The P function waits for the sem_count>0 which means it can then acquire the semaphore. It puts the wait channel to sleep by calling wchan_sleep() on all threads in the wait channel of the semaphore. 
wchan_wakeone() is called in the V implementation of the semaphore. The V method is called when we want to release the semaphore. So after incrementing the sem_count, we then wake up the threads waiting on this semaphore in the wait channel of the semaphore, aka releasing the semaphore.

10) As seen in the P implementation of the semaphore the sem_lock is acquired. Then wchan_sleep is called on with the sem_lock. This means that wchan_sleep is going to be running atomically. wchan_sleep calls thread_switch with S_SLEEP mode. The thread_switch function releases the spinlock after putting the thread in the sleep queue. This way we ensure that no race condition can occur before the thread is queued in the sleep thread. This way a thread can never miss a wake up call since the whole sequence happens atomically. 

